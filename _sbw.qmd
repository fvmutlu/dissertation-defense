## Cache Read Rate Control

Placeholder.

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Cache Read Bandwidth
**Premise:** Initial model assumes cache read rate is constant across objects in virtual plane each slot.

::: {style="font-size: 70%;"}
```{=tex}
\begin{equation*}
    \color{#808080}{V^k_n(t+1) \leq \Big(V^k_n(t) - \sum_{\jin}} \color{#C8102E}{\boldsymbol{r_{n_j}}} \color{#808080}{s\knjt - \sum\limits_{\bin}\mu^k_{nb}(t)  \Big)^+ + A^k_n(t) + \sum\limits_{\ain}\mu^k_{an}(t)}    
\end{equation*}
```
:::

**Hypothesis:** We can control read rate allocations in the virtual plane for better performance.

::: {style="font-size: 70%;"}
```{=tex}
\begin{equation*}
    \color{#808080}{V^k_n(t+1) \leq \Big(V^k_n(t) - \sum_{\jin}} \color{#C8102E}{\boldsymbol{r\knjt}} \color{#808080}{s\knjt - \sum\limits_{\bin}\mu^k_{nb}(t)  \Big)^+ + A^k_n(t) + \sum\limits_{\ain}\mu^k_{an}(t)}    
\end{equation*}
```
:::

**Cache bandwidth constraint:** $\sum_{\kin} r^k_{n_j}(t) \leq R_{n_j}$.

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

::: {.notes}
- The way we'll do that is by enforcing a cache read bandwidth constraint
- Additional control action each time slot, in product form with another control action
- Stability region and its analysis changes significantly
- Complexity of caching problem solution reduces
:::


## Theorem: Stability Region

[VIP stability region]{.body-highlight} $\Lambda$ under *cache bandwidth constraints*:

::: {style="font-size: 80%;"}
```{=tex}
\begin{equation*}
\lambda^k_n \; \leq \; \sum_{\bin} f^k_{nb} - \sum_{\ain} f^k_{an} + \betasum f^k_{n,i}
\end{equation*}
```
:::
<hr>

::: {style="font-size: 70%; text-align: center"}

:::

::: columns
::: {.column width="50%" style="font-size: 70%;"}
$f^k_{ab}$: Time-average VIP flow for $k$ over $(a,b)$.

$\mc{B}_{n,i}$: i-th among all $\sigma_n$ possible cache placement sets at $n$; if $(k,j) \in \mc{B}_{n,i}$ during $t$, $s^k_{n_j}(t)$ = 1.
:::
::: {.column width="50%" style="font-size: 70%;"}
$f^k_{n,i}$: Average VIPs of $k$ removed via caching under placement $\mc{B}_{n,i}$.

$\beta_{n,i}$: Fraction of time objects at $n$ are placed according to $\mc{B}_{n,i}$; $0 \leq \beta_{n,i} \leq 1$ and $\sum^{\sigma_n}_{i=1} \beta_{n,i} = 1$.
:::
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::


## Virtual Plane Caching

::: {style="font-size: 80%;"}
Ignore penalties ($\omega=0$); revised optimization problem for caching:

```{=tex}
\begin{align*}
    \text{maximize}
        & \quad \sum_{\kin} \sum_{\jin} r\knjt s\knjt V\knt \label{eq:mt_sbw_cost}\\
    \text{subject to} 
        & \quad \sum_{\kin} s\knjt \leq L_{n_j}, \; \forall \jin \label{eq:mt_sbw_const1}\\
        & \quad \sum_{\jin} s\knjt \leq 1, \; \forall \kin \label{eq:mt_sbw_const2}\\
        & \quad s\knjt \in \{0,1\}, \; \forall \kin, \, \jin \label{eq:mt_sbw_const3}\\
        & \quad \sum_{\kin} r\knjt \leq R_{n_j}, \; \forall \jin \label{eq:mt_sbw_const4}
\end{align*}
```
:::

::: {.footer}
Optimization Framework
:::

::: {.notes}
- Placeholder
:::

## Lemma

::: {style="font-size: 85%;"}
Given $k_1, k_2, \cdots, k_{J_n}$ such that $V^{k_1}_n(t) \geq V^{k_2}_n(t) \geq ... \geq V^{k_{J_n}}_n(t)$, perform [caching allocations]{.body-highlight} by choosing $r\knjt$ and $s\knjt$ for each $\jin$ greedily as follows.

```{=tex}
\begin{equation*}
    r\knjt =
    \left \{ \begin{array}{ll}
        R_{n_j}, & \text{if} \; k = k_j \; \text{and} \; V\knt > 0 \\
        0, & \text{otherwise}
    \end{array} \right.
\end{equation*}
```
```{=tex}
\begin{equation*}
    s\knjt =
    \left\{ \begin{array}{ll}
        1, & \text{if} \; k = k_j \; \text{and} \; V\knt > 0 \\
        0, & \text{otherwise}
    \end{array} \right.
\end{equation*}
```

This is like the *backpressure* solution for forwarding.
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Theorem

::: {style="font-size: 80%;"}
For arrival rate vector $\boldsymbol{\lambda}$, if there exists $\boldsymbol{\epsilon}$ such that $\boldsymbol{\lambda} + \boldsymbol{\epsilon} \in \Lambda$, then:

```{=tex}
\begin{equation*}
    \lim\limits_{t \rightarrow \infty} \frac{1}{t} \sum\limits^{t-1}_{\tau=0} \sum\limits_{\nin, \kin} \mathbb{E}[V^k_n(\tau)] \leq \frac{B}{\epsilon}
\end{equation*}
```

where

```{=tex}
\begin{equation*}
\epsilon = \min_{\nin,\kin} ((\epsilon^k_n)_{\nin,\kin})
\end{equation*}
```
```{=tex}
\begin{equation*}
    B = \sum_{\nin} \bigg( \sum_{\kin}A^k_{n,max} + \sum_{\ain}C_{an} + \sum_{\bin}C_{nb} + \sum_{\jin} R_{n_j} \bigg)^2
\end{equation*}
```
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Data Plane Caching

When data for $k \not \in \bigcup_{\jin} \mc{K}_{n_j}(\tau)$ arrives at $n$ at instance $\tau$, [data plane caching policy]{.body-highlight} at $n$ behaves as follows:

::: {style="font-size: 65%;"}
```pseudocode
#| html-line-number: true
\begin{algorithm}
\caption{Data Plane Caching w/ Virtual Plane Cache Read Rate Control}
\begin{algorithmic}
    \State Find cache tier $j^* = \argmax_{\jin} \bar{F}^k_{n_j}(t)$.
    \If{$\bar{F}^k_{n_{j^*}}(t) \geq \max_{\{ b:(n,b) \in \mc{L}^k \}} \bar{F}_{nb}^k(t)$}
        \If{$\bar{F}_{n,in}^k(t) > 0$ and $|\mc{K}_{n_{j^*}}| < L_{n_{j^*}}$}
            \State Admit $k$ into $j^*$.
        \Else
            \State Find $k_{min} = \argmin_{k \in \mc{K}_{n_{j^*}}(\tau)} \bar{F}_{n,in}^k(t)$.
            \If{$\bar{F}_{n,in}^k(t) > \bar{F}_{n,in}^{k_{min}}(t)$}
                \State Replace $k_{min}$ with $k$, and restart procedure for $k_{min}$.
            \EndIf
        \EndIf
    \EndIf
\end{algorithmic}
\end{algorithm}
```
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Greedy

::: columns
::: {.column width=50%}
::: {style="font-size: 45%;"}
```pseudocode
#| html-line-number: true
#| html-caption-prefix: "Procedure:"
\begin{algorithm}
\caption{Virtual Plane Caching}
\begin{algorithmic}
    \State Find $k_1, k_2, ..., k_K$ with $V^{k_1}_n(t) \geq V^{k_2}_n(t) \geq ... V^{k_{K}}_n(t)$.
    \State Initialize $i \gets 1$.
    \While{$\sum_{\kin} s\knjt < L_{n_j}, \;\; \sum_{\kin} r\knjt < R_{n_j}, \; \exists \, \jin$ $\hspace{35pt}$ and $V^{k_i}_n(t) > 0$ and $i \leq K$}
        \State $j^* \gets \argmax\limits_{\jin : \sum\limits_{\kin} s\knjt < L_{n_j}} \left(R_{n_j} - \sum\limits_{\kin} s\knjt r\knjt \right) V^{k_i}_n(t)$.
        \State $s^{k_i}_{n_{j^*}}(t) \gets 1$, $r^{k_i}_{n_{j^*}}(t) \gets \min\left( \big(R_{n_j} - \sum_{\kin} s\knjt r\knjt \big), V^{k_i}_n(t)\right)$.
        \State $i \gets i+1$
    \EndWhile
\end{algorithmic}
\end{algorithm}
```
```pseudocode
#| html-line-number: true
#| html-caption-prefix: "Procedure:"
\begin{algorithm}
\caption{Virtual Plane Forwarding}
\begin{algorithmic}
    \State Initialize set $X_n \gets \{(b, k): \bin, \kin, (n,b) \in \mc{L}^k \}$
    \While{$\sum_{\kin} \mu^k_{nb}(t) < C_{bn}, \; \exists \, \nbin$ and $X_n \not = \varnothing$ \\ $\hspace{35pt}$ and $V^{k^*}_n(t) - V^{k^*}_{b^*}(t) > 0$}
        \State $(b^*,k^*) \gets \argmax_{(b,k) \in X_n} \left( V^k_n(t) - V^k_b(t) \right)$
        \State $\mu^{k^*}_{nb^*}(t) \gets \min \Big( \big( C_{bn} - \sum_{\kin} \mu^k_{nb}(t) \big),$ \\ $\big( V^{k^*}_n(t) - \sum_{\jin} s^{k^*}_{n_j}(t) r^{k^*}_{n_j}(t) - \sum_{\nbin^{k^*}} \mu^{k^*}_{nb}(t) \big) \Big)$
        \State $X_n \gets X_n \setminus \{ (b^*,k^*) \}$
    \EndWhile
\end{algorithmic}
\end{algorithm}
```
:::
:::
::: {.column width=50%}
::: {style="font-size: 75%;"}
- Iterative greedy algorithm.
- First allocates cache capacity and read rate to highest backlog objects.
- Then allocates link bandwidth to largest backlog differential objects.
- Placeholder.
:::
:::
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Properties

::: {style="font-size: 75%;"}
- Under *heavy congestion* where $V\knt \geq \sum_{\nbin^k} C_{bn} + \max\limits_{\jin} R_{n_j}$, for all $t \geq 1, \nin, \kin$, greedy algorithm is equivalent to *backpressure* solution.
- *In general*, given backlog state $\mathbf{V}(t)$, following holds.
```{=tex}
\begin{equation*}
\begin{split}
    & \sum_{\kin,\jin} \hat{F}\knjt V\knt +
    \sum_{\nbin, \kin} \hat{F}^k_{nb}(t) \big(V^k_n(t) - V^k_b(t) \big) \\
    \geq & \sum_{\kin,\jin} F\knjt V\knt +
    \sum_{\nbin, \kin} F^k_{nb}(t) \big(V^k_n(t) - V^k_b(t) \big)
\end{split}
\end{equation*}
```
where $\hat{F}\knjt$ and $\hat{F}^k_{nb}(t)$ denote actual VIP flows under greedy algorithm allocations.
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Experimental Results

::: columns
::: {.column width=50%}
![Sum of backlogs](images/sbw_comp_abilene_075_30_vip-pit-sums.png){width=85% height=85% fig-align="center"}

- Placeholder.
:::
::: {.column width=50%}
![Backlog gap](images/sbw_comp_abilene_075_30_vip-pit-norms.png){width=85% height=85% fig-align="center"}

- Placeholder.
:::
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Experimental Results

![Abilene](images/sbw_comp_abilene_075_30.png){width=90% height=90% fig-align="center"}

![Geant](images/sbw_comp_geant_075_30.png){width=90% height=90% fig-align="center"}

::: {.footer}
Virtual Plane Cache Read Rate Control
:::