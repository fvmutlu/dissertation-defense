## Cache Read Rate Control

Placeholder.

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Cache Read Bandwidth
Model assumes read rate of each object is independent

::: {style="font-size: 70%;"}
```{=tex}
\begin{equation*}
    V^k_n(t+1) \leq \Big(V\knt - \sum\limits_{\jin} r_{n_j} s\knjt - \sum\limits_{\bin}\mu^k_{nb}(t) \Big)^+ + A^k_n(t) 
    + \sum\limits_{\ain}\mu^k_{an}(t)
\end{equation*}
```
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

::: {.notes}
- We treat the read rate parameter as if it is independent for each object, which indicates that there is a guaranteeable rate that can be provided per object, no matter how many objects are cached in that tier
- This is an okay assumption, but given the strict rate limitations we're working with, is not great
:::

## Cache Read Bandwidth
**Premise:** Initial model assumes cache read rate is constant across objects in virtual plane each slot.

::: {style="font-size: 70%;"}
```{=tex}
\begin{equation*}
    \color{#808080}{V^k_n(t+1) \leq \Big(V^k_n(t) - \sum_{\jin}} \color{#C8102E}{r_{n_j}} \color{#808080}{s\knjt - \sum\limits_{\bin}\mu^k_{nb}(t)  \Big)^+ + A^k_n(t) + \sum\limits_{\ain}\mu^k_{an}(t)}    
\end{equation*}
```
:::

**Hypothesis:** We can control read rate allocations in the virtual plane for better performance.

::: {style="font-size: 70%;"}
```{=tex}
\begin{equation*}
    \color{#808080}{V^k_n(t+1) \leq \Big(V^k_n(t) - \sum_{\jin}} \color{#C8102E}{r\knjt} \color{#808080}{s\knjt - \sum\limits_{\bin}\mu^k_{nb}(t)  \Big)^+ + A^k_n(t) + \sum\limits_{\ain}\mu^k_{an}(t)}    
\end{equation*}
```
:::

**Cache bandwidth constraint:** $\sum_{\kin} r^k_{n_j}(t) \leq R_{n_j}$.

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

::: {.notes}
- The way we'll do that is by enforcing a cache read bandwidth constraint
- Additional control action each time slot, in product form with another control action
- Stability region and its analysis changes significantly
- Complexity of caching problem solution reduces
:::

## Lemma

::: {style="font-size: 80%;"}
Given $k_1, k_2, \cdots, k_{J_n}$ such that $V^{k_1}_n(t) \geq V^{k_2}_n(t) \geq ... \geq V^{k_{J_n}}_n(t)$, perform [caching allocations]{.body-highlight} by choosing $r\knjt$ and $s\knjt$ for each $\jin$ greedily as follows.

```{=tex}
\begin{equation*}
    r\knjt =
    \left \{ \begin{array}{ll}
        R_{n_j}, & \text{if} \; k = k_j \; \text{and} \; V\knt > 0 \\
        0, & \text{otherwise}
    \end{array} \right.
\end{equation*}
```
```{=tex}
\begin{equation*}
    s\knjt =
    \left\{ \begin{array}{ll}
        1, & \text{if} \; k = k_j \; \text{and} \; V\knt > 0 \\
        0, & \text{otherwise}
    \end{array} \right.
\end{equation*}
```

This is akin to *backpressure* solution for forwarding.
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Theorem

::: {style="font-size: 80%;"}
For arrival rate vector $\boldsymbol{\lambda}$, if there exists $\boldsymbol{\epsilon}$ such that $\boldsymbol{\lambda} + \boldsymbol{\epsilon} \in \Lambda$, then:

```{=tex}
\begin{equation*}
    \lim\limits_{t \rightarrow \infty} \frac{1}{t} \sum\limits^{t-1}_{\tau=0} \sum\limits_{\nin, \kin} \mathbb{E}[V^k_n(\tau)] \leq \frac{B}{\epsilon}
\end{equation*}
```

where

```{=tex}
\begin{equation*}
\epsilon = \min_{\nin,\kin} ((\epsilon^k_n)_{\nin,\kin})
\end{equation*}
```
```{=tex}
\begin{equation*}
    B = \sum_{\nin} \bigg( \sum_{\kin}A^k_{n,max} + \sum_{\ain}C_{an} + \sum_{\bin}C_{nb} + \sum_{\jin} R_{n_j} \bigg)^2
\end{equation*}
```
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Data Plane Caching

When data for $k \not \in \bigcup_{\jin} \mc{K}_{n_j}(\tau)$ arrives at $n$ at instance $\tau$, [data plane caching policy]{.body-highlight} at $n$ behaves as follows:

::: {style="font-size: 65%;"}
```pseudocode
#| html-line-number: true
\begin{algorithm}
\caption{Data Plane Caching w/ Virtual Plane Cache Read Rate Control}
\begin{algorithmic}
    \State Find cache tier $j^* = \argmax_{\jin} \bar{F}^k_{n_j}(t)$.
    \If{$\bar{F}^k_{n_{j^*}}(t) \geq \max_{\{ b:(n,b) \in \mc{L}^k \}} \bar{F}_{nb}^k(t)$}
        \If{$\bar{F}_{n,in}^k(t) > 0$ and $|\mc{K}_{n_{j^*}}| < L_{n_{j^*}}$}
            \State Admit $k$ into $j^*$.
        \Else
            \State Find $k_{min} = \argmin_{k \in \mc{K}_{n_{j^*}}(\tau)} \bar{F}_{n,in}^k(t)$.
            \If{$\bar{F}_{n,in}^k(t) > \bar{F}_{n,in}^{k_{min}}(t)$}
                \State Replace $k_{min}$ with $k$, and restart procedure for $k_{min}$.
            \EndIf
        \EndIf
    \EndIf
\end{algorithmic}
\end{algorithm}
```
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::

## Greedy

::: columns
::: {.column width=50%}
::: {style="font-size: 45%;"}
```pseudocode
#| html-line-number: true
#| html-caption-prefix: "Procedure:"
\begin{algorithm}
\caption{Virtual Plane Caching}
\begin{algorithmic}
    \State Find $k_1, k_2, ..., k_K$ with $V^{k_1}_n(t) \geq V^{k_2}_n(t) \geq ... V^{k_{K}}_n(t)$.
    \State Initialize $i \gets 1$.
    \While{$\sum_{\kin} s\knjt < L_{n_j}, \;\; \sum_{\kin} r\knjt < R_{n_j}, \; \exists \, \jin$ $\hspace{35pt}$ and $V^{k_i}_n(t) > 0$ and $i \leq K$}
        \State $j^* \gets \argmax\limits_{\jin : \sum\limits_{\kin} s\knjt < L_{n_j}} \left(R_{n_j} - \sum\limits_{\kin} s\knjt r\knjt \right) V^{k_i}_n(t)$.
        \State $s^{k_i}_{n_{j^*}}(t) \gets 1$, $r^{k_i}_{n_{j^*}}(t) \gets \min\left( \big(R_{n_j} - \sum_{\kin} s\knjt r\knjt \big), V^{k_i}_n(t)\right)$.
        \State $i \gets i+1$
    \EndWhile
\end{algorithmic}
\end{algorithm}
```
```pseudocode
#| html-line-number: true
#| html-caption-prefix: "Procedure:"
\begin{algorithm}
\caption{Virtual Plane Forwarding}
\begin{algorithmic}
    \State Initialize set $X_n \gets \{(b, k): \bin, \kin, (n,b) \in \mc{L}^k \}$
    \While{$\sum_{\kin} \mu^k_{nb}(t) < C_{bn}, \; \exists \, \nbin$ and $X_n \not = \varnothing$ \\ $\hspace{35pt}$ and $V^{k^*}_n(t) - V^{k^*}_{b^*}(t) > 0$}
        \State $(b^*,k^*) \gets \argmax_{(b,k) \in X_n} \left( V^k_n(t) - V^k_b(t) \right)$
        \State $\mu^{k^*}_{nb^*}(t) \gets \min \Big( \big( C_{bn} - \sum_{\kin} \mu^k_{nb}(t) \big),$ \\ $\big( V^{k^*}_n(t) - \sum_{\jin} s^{k^*}_{n_j}(t) r^{k^*}_{n_j}(t) - \sum_{\nbin^{k^*}} \mu^{k^*}_{nb}(t) \big) \Big)$
        \State $X_n \gets X_n \setminus \{ (b^*,k^*) \}$
    \EndWhile
\end{algorithmic}
\end{algorithm}
```
:::
:::
::: {.column width=50%}
::: {style="font-size: 75%;"}
- Iterative greedy algorithm.
- First allocates cache capacity and read rate to highest backlog objects.
- Then allocates link bandwidth to largest backlog differential objects.
- Placeholder.
:::
:::
:::

::: {.footer}
Virtual Plane Cache Read Rate Control
:::