## System Model

![](images/system_model.svg){fig-align="center" width="60%" height="60%"}

::: {.footer}
System Model
:::

::: {.notes}
- Here's a simple illustration of the system model the separation and interaction between the virtual and data planes we're adopting from the VIP paper.
- The data plane is where actual network functionality is performed. The virtual plane uses the request arrival information from the data plane; its where control decisions are made.
:::

## Data Plane Model
Object-level data plane model based on general ICN principles:

::: {.incremental}
-   Unit of content is *data object*.
-   Each object $\kin$ has a unique source $\mc{S}(k)$.
-   Every data object has the same *unit size*.
-   Any node $n \not = \mc{S}(k)$ can cache $k$.
:::

::: {.footer}
System Model
:::

::: {.notes}
- The principles of the data plane are based on those of a classical ICN.
- We use "data object" as the unit of content in the network and assume that each object has a unique source node.
- We particularly assume every object has the same size, which is a crucial assumption we'll need to remember for later.
- Requests can enter network at any node. A request for an object can be met with a data response at the source node for that object or at any node that caches that object.
- Those data responses will follow the path of the request back to the requester (inverse of the path, of course)
:::

## Data Plane Model

::: {.incremental}
[• Requests can enter network at any node.]{.fragment fragment-index=1}

[• Responses carry data back, following reverse path.]{.fragment fragment-index=2}

[• Nodes can respond from their cache.]{.fragment fragment-index=3}
:::

::: {.r-stack}
![](images/dpmodel_1.svg){.fragment fragment-index=1 width="540" height="300" fig-align="center"}

![](images/dpmodel_2.svg){.fragment fragment-index=2 width="540" height="300" fig-align="center"}

![](images/dpmodel_3.svg){.fragment fragment-index=3 width="540" height="300" fig-align="center"}
:::

::: {.footer}
System Model
:::

## Data Plane Model

::: columns
::: {.column width=80%}
We propose following [multi-tiered caching model]{.body-highlight} properties:

-   Any node can have any number of cache tiers
:::
::: {.column width=20%}
<img src="images/tier1_admit.svg" style="display: block; margin-left: auto; margin-right: 10px; width: 80%; height: 80%; transform: translateY(25%);">
:::
:::

::: {.footer}
System Model
:::

::: {.notes}
- The multi-tiered caching model I propose adds the following properties to those basic mechanisms.
- Any node can have cache tiers and can cache any object in one of those tiers unless it already sources that object.
- A node can cache an object in at most one of its tiers. This means that we don't duplicate objects across cache tiers. This is also something critical to keep in mind.
- An object evicted from one tier can migrate to another tier at the same node. So an eviction from one tier is not necessarily final for an object.
:::

## Data Plane Model

::: columns
::: {.column width=80%}
We propose following [multi-tiered caching model]{.body-highlight} properties:

-   Any node can have any number of cache tiers
-   A node can cache an object in at most one of its tiers ([cache exclusivity]{.body-highlight})
:::
::: {.column width=20%}
<img src="images/tier2_admit.svg" style="display: block; margin-left: auto; margin-right: 0; width: 85%; height: 85%; transform: translateY(24%);">
:::
:::

::: {.footer}
System Model
:::

## Data Plane Model

::: columns
::: {.column width=80%}
We propose following [multi-tiered caching model]{.body-highlight} properties:

-   Any node can have any number of cache tiers
-   A node can cache an object in at most one of its tiers ([cache exclusivity]{.body-highlight})
-   An object evicted from one tier can [migrate]{.body-highlight} to another tier at the same node
:::
::: {.column width=20%}
<img src="images/migration.svg" style="display: block; margin-left: auto; margin-right: 0; width: 100%; height: 100%; transform: translateY(25%);">
:::
:::

::: {.footer}
System Model
:::

## Virtual Plane Model

::: {style="font-size: 75%;"}
Virtual control plane model using the [VIP framework]{.body-highlight}[^vipog]:

::: {.incremental}
-  *Virtual interest packets (VIPs)* generated alongside exogenous requests.
    -  Every node keeps a [VIP counter]{.body-highlight} for every object $\kin$.
    -  VIPs are removed at object sources and caching nodes.
-  Discrete time slots indexed $t = 1, 2, ...$; following happens beginning of each time slot:
    - Nodes update neighbors with local counter states using small message.
    - VIPs are removed via caching and forwarded to neighbors, counters updated.
:::
:::

[^vipog]: "VIP: A framework for joint dynamic forwarding and caching in named data networks", Yeh, E., Ho, T., Cui, Y., Burd, M., Liu, R., & Leong, D., ACM ICN 2014

::: {.footer}
System Model
:::

::: {.notes}
- Now, on to the virtual plane model, which is largely based on the original VIP paper. We'll go over it briefly.
- First off, anytime an exogenous request enters the data plane network, a virtual interest packet (VIP for short) is generated in the virtual plane at that node. These VIPs can only be removed at sources or caching points.
- Each node maintains a VIP counter for each object in the network. We can interpret these counts as queues that describe unsatisfied demand for objects. Another useful way to think of these counters is as "potential" values, much like electrical potential, where the potential is high at request entry points and low at sources and caching points.
- We're considering discrete time slots in the virtual plane where caching and forwarding decisions for each time slot are made at the beginning of that time slot.
:::

## VIP Queue Dynamics
[VIP queuing dynamics]{.body-highlight} with multi-tiered caching for object $\kin$ at node $\nin$, where $(x)^+ = max(x,0)$:

::: {style="font-size: 70%;"}
```{=tex}
\begin{equation*}
    V^k_n(t+1) \leq \Big(V\knt - \textcolor{#C8102E}{\sum\limits_{\jin} r_{n_j} s\knjt} - \sum\limits_{\bin}\mu^k_{nb}(t) \Big)^+ + A\knt 
    + \sum\limits_{\ain}\mu^k_{an}(t)    
\end{equation*}
```
:::
<hr>

::: columns
::: {.column width="50%" style="font-size: 75%;"}
$V^k_n(t)$: VIP count for $k$ at $n$ during $t$

$A^k_n(t)$: Number of exogenous requests for $k$ at $n$ during $t$

$\mu^k_{ab}(t)$: Allocated rate of VIPs for $k$ over $(a,b)$ during $t$
:::
::: {.column width="50%" style="font-size: 75%;"}
$\mathcal{J}_n$: Set of cache tiers at $n$

$r_{n_j}$: Read rate of tier $j$ at $n$

$s^k_{n_j}(t)$: Caching state of $k$ in tier $j$ at $n$ at the beginning of $t$
:::
:::

::: {.footer}
System Model
:::

::: {.notes}
- This inequality shows how VIP counts change from slot to slot in the virtual plane
- First term is VIPs forwarded away from the node, then we have the exogenous arrivals, then VIPs that arrive from other nodes and finally, VIPs removed due to caching. Notice that this term is dependent on the read rates of cache tiers.
:::